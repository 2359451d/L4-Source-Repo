//package util.test.rule;
//
//import annotation.TestResourcePath;
//import ast.visitor.PascalCustomLexer;
//import ast.visitor.PascalParser;
//import jdk.jfr.Description;
//import org.antlr.v4.runtime.CharStreams;
//import org.antlr.v4.runtime.CommonTokenStream;
//import org.junit.rules.TestName;
//import org.junit.runners.model.Statement;
//import util.ResourceHelper;
//
//import java.io.InputStream;
//
///**
// * Custom Junit TestRule to setup the lexer & parser for the specific test method
// * 1. Setup lexer & parser based on the name of current test method - testXXX
// * - then it would take "XXX.pas" as the filename of source Pascal program
// * - resource path should be specified in test class
// * - please strictly follow the naming convention
// * 2. Evaluate all the statements inside the test method
// * 3. Execute remaining operations if any
// */
//@Deprecated
//public class TestParse extends TestName {
//
//    private volatile PascalCustomLexer lexer;
//    private volatile PascalParser parser;
//
//    protected void starting(Description d) {
//        super.starting(d);
//    }
//
//    @Override
//    public Statement apply(Statement base, Description description) {
//        return new Statement() {
//            /**
//             * Imitate Around Advice
//             *
//             * @throws Throwable
//             */
//            @Override
//            public void evaluate() throws Throwable {
//                // load information of the Description to parent's field
//                TestParse.this.startingQuietly(description);
//                Class<?> testClass = Class.forName(description.getClassName());
//                System.out.printf("\n==========Testing starts - [%s.%s]=========\n",
//                        description.getClassName(),
//                        getMethodName());
//                try {
//                    if (testClass.isAnnotationPresent(TestResourcePath.class)) {
//                        TestResourcePath testResourcePath = testClass.getAnnotation(TestResourcePath.class);
//
//                        String path = null;
//                        StringBuilder stringBuilder = new StringBuilder(getMethodName());
//                        int length = stringBuilder.length();
//                        stringBuilder.replace(0, 9, "");
//                        int suffixStartPos = stringBuilder.lastIndexOf("W");
//                        if (getMethodName().endsWith("WithSuccess")) {
//                            path = testResourcePath.value() + "testParseWithSuccess/";
//                        } else {
//                            path = testResourcePath.value() + "testParseWithError/";
//                        }
//                        stringBuilder.replace(suffixStartPos, length, "");
//                        //String path = testResourcePath.value();
//                        // setup lexer & parser for specific test method
//                        // fileName based on truncated method name with the prefix of "test"
//                        // i.e. testXXX with filename of XXX.pas
//                        String fileName = stringBuilder.toString();
//
//                        String file = ResourceHelper.concatenateFileNameWithSuffix(fileName, "pas");
//                        System.out.println("Testing Resource = " + path + file);
//                        InputStream resourceAsStream = testClass.getResourceAsStream(path + file);
//                        if (resourceAsStream == null) throw new Exception("Testing Resources Does Not Exist!");
//
//                        // create a new lexer, processing the input(CharStream)
//                        lexer = new PascalCustomLexer(CharStreams.fromStream(resourceAsStream));
//
//                        // create the buffer of lexer, store all the tokens generated by the lexer
//                        CommonTokenStream tokens = new CommonTokenStream(lexer);
//
//                        // create a parser, processing the content of the buffer of lexer
//                        parser = new PascalParser(tokens);
//                    } else throw new Exception("No Testing Resource Path Defined!");
//                } catch (Exception exception) {
//                    exception.printStackTrace();
//                }
//
//                try {
//                    base.evaluate();
//                } finally {
//                    System.out.printf("==========Testing ends - [%s.%s]=========\n",
//                            description.getClassName(),
//                            getMethodName());
//                }
//            }
//        };
//    }
//
//    /**
//     * Fetch test suite information by Description
//     *
//     * @param description
//     */
//    private void startingQuietly(Description description) {
//        try {
//            this.starting(description);
//        } catch (Throwable var4) {
//            var4.printStackTrace();
//        }
//    }
//
//    public PascalCustomLexer getLexer() {
//        return lexer;
//    }
//
//    public PascalParser getParser() {
//        return parser;
//    }
//}
